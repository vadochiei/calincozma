(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["rmiz-umd"] = {}, global.React, global.ReactDOM));
})(this, (function (exports, React, reactDom) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  // focus - focusOptions - preventScroll polyfill
  (function() {
    if (
      typeof window === "undefined" ||
      typeof document === "undefined" ||
      typeof HTMLElement === "undefined"
    ) {
      return;
    }

    var supportsPreventScrollOption = false;
    try {
      var focusElem = document.createElement("div");
      focusElem.addEventListener(
        "focus",
        function(event) {
          event.preventDefault();
          event.stopPropagation();
        },
        true
      );
      focusElem.focus(
        Object.defineProperty({}, "preventScroll", {
          get: function() {
            // Edge v18 gives a false positive for supporting inputs
            if (
              navigator &&
              typeof navigator.userAgent !== 'undefined' &&
              navigator.userAgent &&
              navigator.userAgent.match(/Edge\/1[7-8]/)) {
                return supportsPreventScrollOption = false
            }

            supportsPreventScrollOption = true;
          }
        })
      );
    } catch (e) {}

    if (
      HTMLElement.prototype.nativeFocus === undefined &&
      !supportsPreventScrollOption
    ) {
      HTMLElement.prototype.nativeFocus = HTMLElement.prototype.focus;

      var calcScrollableElements = function(element) {
        var parent = element.parentNode;
        var scrollableElements = [];
        var rootScrollingElement =
          document.scrollingElement || document.documentElement;

        while (parent && parent !== rootScrollingElement) {
          if (
            parent.offsetHeight < parent.scrollHeight ||
            parent.offsetWidth < parent.scrollWidth
          ) {
            scrollableElements.push([
              parent,
              parent.scrollTop,
              parent.scrollLeft
            ]);
          }
          parent = parent.parentNode;
        }
        parent = rootScrollingElement;
        scrollableElements.push([parent, parent.scrollTop, parent.scrollLeft]);

        return scrollableElements;
      };

      var restoreScrollPosition = function(scrollableElements) {
        for (var i = 0; i < scrollableElements.length; i++) {
          scrollableElements[i][0].scrollTop = scrollableElements[i][1];
          scrollableElements[i][0].scrollLeft = scrollableElements[i][2];
        }
        scrollableElements = [];
      };

      var patchedFocus = function(args) {
        if (args && args.preventScroll) {
          var evScrollableElements = calcScrollableElements(this);
          this.nativeFocus();
          if (typeof setTimeout === 'function') {
            setTimeout(function () {
              restoreScrollPosition(evScrollableElements);
            }, 0);
          } else {
            restoreScrollPosition(evScrollableElements);          
          }
        }
        else {
          this.nativeFocus();
        }
      };

      HTMLElement.prototype.focus = patchedFocus;
    }
  })();

  // https://github.com/streamich/react-use/blob/master/src/useEffectOnce.ts
  var useEffectOnce = function (effect) {
      React.useEffect(effect, []); // eslint-disable-line
  };

  // https://github.com/streamich/react-use/blob/master/src/useUnmount.ts
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var useUnmount = function (fn) {
      var fnRef = React.useRef(fn);
      // update the ref each render so if it change the newest callback will be invoked
      fnRef.current = fn;
      useEffectOnce(function () { return function () { return fnRef.current(); }; });
  };

  // https://github.com/streamich/react-use/blob/master/src/useRafState.ts
  var useRafState = function (initialState) {
      var frame = React.useRef(0);
      var _a = React.useState(initialState), state = _a[0], setState = _a[1];
      var setRafState = React.useCallback(function (value) {
          cancelAnimationFrame(frame.current);
          frame.current = requestAnimationFrame(function () {
              setState(value);
          });
      }, []);
      useUnmount(function () {
          cancelAnimationFrame(frame.current);
      });
      return [state, setRafState];
  };

  // https://github.com/streamich/react-use/blob/master/src/useWindowSize.ts
  var useWindowSize = function (initialWidth, initialHeight) {
      if (initialWidth === void 0) { initialWidth = Infinity; }
      if (initialHeight === void 0) { initialHeight = Infinity; }
      var isBrowser = typeof window !== 'undefined';
      var _a = useRafState({
          width: isBrowser ? window.innerWidth : initialWidth,
          height: isBrowser ? window.innerHeight : initialHeight,
      }), state = _a[0], setState = _a[1];
      React.useEffect(function () {
          if (isBrowser) {
              var handler_1 = function () {
                  setState({
                      width: window.innerWidth,
                      height: window.innerHeight,
                  });
              };
              window.addEventListener('resize', handler_1);
              return function () {
                  window.removeEventListener('resize', handler_1);
              };
          }
      }, [isBrowser, setState]);
      return state;
  };

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  var toDurationString = function (duration) { return "".concat(duration, "ms"); };
  var getScale = function (_a) {
      var height = _a.height, innerHeight = _a.innerHeight, innerWidth = _a.innerWidth, width = _a.width, zoomMargin = _a.zoomMargin;
      var scaleX = innerWidth / (width + zoomMargin);
      var scaleY = innerHeight / (height + zoomMargin);
      var scale = Math.min(scaleX, scaleY);
      return scale;
  };
  var getModalContentStyle = function (_a) {
      var height = _a.height, innerHeight = _a.innerHeight, innerWidth = _a.innerWidth, isLoaded = _a.isLoaded, isUnloading = _a.isUnloading, left = _a.left, originalTransform = _a.originalTransform, top = _a.top, transitionDuration = _a.transitionDuration, width = _a.width, zoomMargin = _a.zoomMargin;
      var transitionDurationString = toDurationString(transitionDuration);
      if (!isLoaded || isUnloading) {
          var initTransform = __spreadArray([
              'scale(1)',
              'translate(0, 0)'
          ], (originalTransform ? [originalTransform] : []), true).join(' ');
          return {
              height: height,
              left: left,
              top: top,
              transform: initTransform,
              WebkitTransform: initTransform,
              transitionDuration: transitionDurationString,
              width: width,
          };
      }
      // Get amount to scale item
      var scale = getScale({
          height: height,
          innerWidth: innerWidth,
          innerHeight: innerHeight,
          width: width,
          zoomMargin: zoomMargin,
      });
      // Get the the coords for center of the viewport
      var viewportX = innerWidth / 2;
      var viewportY = innerHeight / 2;
      // Get the coords for center of the parent item
      var childCenterX = left + width / 2;
      var childCenterY = top + height / 2;
      // Get offset amounts for item coords to be centered on screen
      var translateX = (viewportX - childCenterX) / scale;
      var translateY = (viewportY - childCenterY) / scale;
      // Build transform style, including any original transform
      var transform = __spreadArray([
          "scale(".concat(scale, ")"),
          "translate(".concat(translateX, "px, ").concat(translateY, "px)")
      ], (originalTransform ? [originalTransform] : []), true).join(' ');
      return {
          height: height,
          left: left,
          top: top,
          transform: transform,
          WebkitTransform: transform,
          transitionDuration: transitionDurationString,
          width: width,
      };
  };
  var getModalOverlayStyle = function (_a) {
      var isLoaded = _a.isLoaded, isUnloading = _a.isUnloading, overlayBgColorEnd = _a.overlayBgColorEnd, overlayBgColorStart = _a.overlayBgColorStart, transitionDuration = _a.transitionDuration, zoomZindex = _a.zoomZindex;
      var style = {
          backgroundColor: overlayBgColorStart,
          transitionDuration: toDurationString(transitionDuration),
          zIndex: zoomZindex,
      };
      if (isLoaded && !isUnloading) {
          style.backgroundColor = overlayBgColorEnd;
      }
      return style;
  };
  var pseudoParentEl = {
      getBoundingClientRect: function () { return ({
          height: 0,
          left: 0,
          top: 0,
          width: 0,
      }); },
      style: {
          transform: null,
      },
  };

  var UncontrolledActivated = function (_a) {
      var children = _a.children, _b = _a.closeText, closeText = _b === void 0 ? 'Unzoom Image' : _b, onUnload = _a.onUnload, onLoad = _a.onLoad, _c = _a.overlayBgColorEnd, overlayBgColorEnd = _c === void 0 ? 'rgba(255, 255, 255, 0.95)' : _c, _d = _a.overlayBgColorStart, overlayBgColorStart = _d === void 0 ? 'rgba(255, 255, 255, 0)' : _d, parentRef = _a.parentRef, _e = _a.portalEl, portalEl = _e === void 0 ? document.body : _e, _f = _a.scrollableEl, scrollableEl = _f === void 0 ? window : _f, _g = _a.transitionDuration, transitionDuration = _g === void 0 ? 300 : _g, _h = _a.zoomMargin, zoomMargin = _h === void 0 ? 0 : _h, _j = _a.zoomZindex, zoomZindex = _j === void 0 ? 2147483647 : _j;
      var btnRef = React.useRef(null);
      var _k = React.useState(0), forceUpdate = _k[1];
      var _l = React.useState(false), isLoaded = _l[0], setIsLoaded = _l[1];
      var _m = React.useState(false), isUnloading = _m[0], setIsUnloading = _m[1];
      var _o = useWindowSize(), innerWidth = _o.width, innerHeight = _o.height;
      // on click, begin unloading
      var handleClick = React.useCallback(function (e) {
          e.preventDefault();
          setIsUnloading(true);
      }, []);
      // on escape, begin unloading
      var handleKeyDown = React.useCallback(function (e) {
          if (e.key === 'Escape' || e.keyCode === 27) {
              e.stopPropagation();
              setIsUnloading(true);
          }
      }, []);
      var handleScroll = React.useCallback(function () {
          forceUpdate(function (n) { return n + 1; });
          if (!isUnloading) {
              setIsUnloading(true);
          }
      }, [isUnloading]);
      // listen for keydown on the document
      React.useEffect(function () {
          document.addEventListener('keydown', handleKeyDown);
          return function () {
              document.removeEventListener('keydown', handleKeyDown);
          };
      }, [handleKeyDown]);
      // listen for scroll and close
      React.useEffect(function () {
          var _a;
          (_a = scrollableEl === null || scrollableEl === void 0 ? void 0 : scrollableEl.addEventListener) === null || _a === void 0 ? void 0 : _a.call(scrollableEl, 'scroll', handleScroll);
          return function () {
              var _a;
              (_a = scrollableEl === null || scrollableEl === void 0 ? void 0 : scrollableEl.removeEventListener) === null || _a === void 0 ? void 0 : _a.call(scrollableEl, 'scroll', handleScroll);
          };
      }, [handleScroll, scrollableEl]);
      // set loaded on mount and focus
      React.useEffect(function () {
          setIsLoaded(true);
          onLoad();
          if (btnRef.current) {
              btnRef.current.focus({ preventScroll: true });
          }
      }, [onLoad]);
      // if unloading, tell parent that we're all done here after Nms
      React.useEffect(function () {
          var unloadTimeout = isUnloading
              ? setTimeout(onUnload, transitionDuration)
              : null;
          return function () {
              if (unloadTimeout) {
                  clearTimeout(unloadTimeout);
              }
          };
      }, [isUnloading, onUnload, transitionDuration]);
      // use parent element or fake one if it's not yet loaded
      var parentEl = parentRef.current || pseudoParentEl;
      // get parent item's dimensions
      var _p = parentEl.getBoundingClientRect(), height = _p.height, left = _p.left, top = _p.top, width = _p.width;
      var overlayStyle = getModalOverlayStyle({
          isLoaded: isLoaded,
          isUnloading: isUnloading,
          overlayBgColorEnd: overlayBgColorEnd,
          overlayBgColorStart: overlayBgColorStart,
          transitionDuration: transitionDuration,
          zoomZindex: zoomZindex,
      });
      var contentStyle = getModalContentStyle({
          height: height,
          isLoaded: isLoaded,
          innerHeight: innerHeight,
          innerWidth: innerWidth,
          isUnloading: isUnloading,
          left: left,
          originalTransform: parentEl.style.transform,
          top: top,
          transitionDuration: transitionDuration,
          width: width,
          zoomMargin: zoomMargin,
      });
      return reactDom.createPortal(React__default["default"].createElement("div", { "aria-label": "Zoomed image", "aria-modal": true, "data-rmiz-overlay": true, role: "dialog", style: overlayStyle },
          React__default["default"].createElement("div", { "data-rmiz-modal-content": true, style: contentStyle }, children),
          React__default["default"].createElement("button", { "aria-label": closeText, "data-rmiz-btn-close": true, onClick: handleClick, ref: btnRef })), portalEl);
  };
  var UncontrolledActivated$1 = React.memo(UncontrolledActivated);

  var Uncontrolled = function (_a) {
      var children = _a.children, _b = _a.closeText, closeText = _b === void 0 ? 'Unzoom image' : _b, _c = _a.overlayBgColorEnd, overlayBgColorEnd = _c === void 0 ? 'rgba(255, 255, 255, 0.95)' : _c, _d = _a.overlayBgColorStart, overlayBgColorStart = _d === void 0 ? 'rgba(255, 255, 255, 0)' : _d, portalEl = _a.portalEl, _e = _a.openText, openText = _e === void 0 ? 'Zoom image' : _e, scrollableEl = _a.scrollableEl, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, _g = _a.wrapElement, WrapElement = _g === void 0 ? 'div' : _g, wrapStyle = _a.wrapStyle, _h = _a.zoomMargin, zoomMargin = _h === void 0 ? 0 : _h, _j = _a.zoomZindex, zoomZindex = _j === void 0 ? 2147483647 : _j;
      var _k = React.useState(false), isActive = _k[0], setIsActive = _k[1];
      var _l = React.useState(false), isChildLoaded = _l[0], setIsChildLoaded = _l[1];
      var wrapRef = React.useRef(null);
      var btnRef = React.useRef(null);
      var handleClickTrigger = React.useCallback(function (e) {
          if (!isActive) {
              e.preventDefault();
              setIsActive(true);
          }
      }, [isActive]);
      var handleChildLoad = React.useCallback(function () {
          setIsChildLoaded(true);
      }, []);
      var handleChildUnload = React.useCallback(function () {
          setIsActive(false);
          setIsChildLoaded(false);
          if (btnRef.current) {
              btnRef.current.focus({ preventScroll: true });
          }
      }, []);
      var isExpanded = isActive && isChildLoaded;
      var wrapType = isExpanded ? 'hidden' : 'visible';
      return (React__default["default"].createElement(React.StrictMode, null,
          React__default["default"].createElement(WrapElement, { "data-rmiz-wrap": wrapType, ref: wrapRef, style: wrapStyle },
              children,
              React__default["default"].createElement("button", { "aria-label": openText, "data-rmiz-btn-open": true, onClick: handleClickTrigger, ref: btnRef }),
              typeof window !== 'undefined' && isActive && (React__default["default"].createElement(UncontrolledActivated$1, { closeText: closeText, onLoad: handleChildLoad, onUnload: handleChildUnload, overlayBgColorEnd: overlayBgColorEnd, overlayBgColorStart: overlayBgColorStart, parentRef: wrapRef, portalEl: portalEl, scrollableEl: scrollableEl, transitionDuration: transitionDuration, zoomMargin: zoomMargin, zoomZindex: zoomZindex }, children)))));
  };
  var Uncontrolled$1 = React.memo(Uncontrolled);

  // https://github.com/streamich/react-use/blob/master/src/usePrevious.ts
  function usePrevious(state) {
      var ref = React.useRef();
      React.useEffect(function () {
          ref.current = state;
      });
      return ref.current;
  }

  var ControlledActivated = function (_a) {
      var children = _a.children, _b = _a.closeText, closeText = _b === void 0 ? 'Unzoom Image' : _b, isActiveFromParent = _a.isActive, onLoad = _a.onLoad, onUnload = _a.onUnload, onZoomChange = _a.onZoomChange, _c = _a.overlayBgColorEnd, overlayBgColorEnd = _c === void 0 ? 'rgba(255, 255, 255, 0.95)' : _c, _d = _a.overlayBgColorStart, overlayBgColorStart = _d === void 0 ? 'rgba(255, 255, 255, 0)' : _d, parentRef = _a.parentRef, _e = _a.portalEl, portalEl = _e === void 0 ? document.body : _e, _f = _a.scrollableEl, scrollableEl = _f === void 0 ? window : _f, _g = _a.transitionDuration, transitionDuration = _g === void 0 ? 300 : _g, _h = _a.zoomMargin, zoomMargin = _h === void 0 ? 0 : _h, _j = _a.zoomZindex, zoomZindex = _j === void 0 ? 2147483647 : _j;
      var btnRef = React.useRef(null);
      var _k = React.useState(0), forceUpdate = _k[1];
      var _l = React.useState(isActiveFromParent), isActive = _l[0], setIsActive = _l[1];
      var _m = React.useState(false), isLoaded = _m[0], setIsLoaded = _m[1];
      var _o = React.useState(false), isUnloading = _o[0], setIsUnloading = _o[1];
      var prevIsActive = usePrevious(isActive);
      var prevIsActiveFromParent = usePrevious(isActiveFromParent);
      var prevIsLoaded = usePrevious(isLoaded);
      var _p = useWindowSize(), innerWidth = _p.width, innerHeight = _p.height;
      // on click, tell caller it should zoom
      var handleClick = React.useCallback(function (e) {
          e.preventDefault();
          if (onZoomChange) {
              onZoomChange(false);
          }
      }, [onZoomChange]);
      // on escape, tell caller it should unzoom
      var handleKeyDown = React.useCallback(function (e) {
          if (isActive && (e.key === 'Escape' || e.keyCode === 27)) {
              e.stopPropagation();
              if (onZoomChange) {
                  onZoomChange(false);
              }
          }
      }, [isActive, onZoomChange]);
      var handleScroll = React.useCallback(function () {
          forceUpdate(function (n) { return n + 1; });
          if (!isUnloading && onZoomChange) {
              onZoomChange(false);
          }
      }, [isUnloading, onZoomChange]);
      // listen for keydown on the document
      React.useEffect(function () {
          document.addEventListener('keydown', handleKeyDown);
          return function () {
              document.removeEventListener('keydown', handleKeyDown);
          };
      }, [handleKeyDown]);
      // listen for scroll and close
      React.useEffect(function () {
          var _a;
          (_a = scrollableEl === null || scrollableEl === void 0 ? void 0 : scrollableEl.addEventListener) === null || _a === void 0 ? void 0 : _a.call(scrollableEl, 'scroll', handleScroll);
          return function () {
              var _a;
              (_a = scrollableEl === null || scrollableEl === void 0 ? void 0 : scrollableEl.removeEventListener) === null || _a === void 0 ? void 0 : _a.call(scrollableEl, 'scroll', handleScroll);
          };
      }, [handleScroll, scrollableEl]);
      // set loaded on mount and focus
      React.useEffect(function () {
          if (!prevIsActive && isActive) {
              setIsLoaded(true);
              if (btnRef.current) {
                  btnRef.current.focus({ preventScroll: true });
              }
          }
      }, [isActive, prevIsActive]);
      React.useEffect(function () {
          // when parent says to deactivate, begin unloading process
          if (prevIsActiveFromParent && !isActiveFromParent) {
              setIsUnloading(true);
          }
          // when parent says to activate, begin active process
          if (!prevIsActiveFromParent && isActiveFromParent) {
              setIsActive(true);
          }
      }, [isActiveFromParent, prevIsActiveFromParent]);
      // if unloading, tell parent that we're all done here after Nms
      React.useEffect(function () {
          var unloadTimeout;
          if (isUnloading) {
              unloadTimeout = setTimeout(function () {
                  setIsLoaded(false);
                  setIsActive(false);
                  setIsUnloading(false);
              }, transitionDuration);
          }
          return function () {
              clearTimeout(unloadTimeout);
          };
      }, [isUnloading, transitionDuration]);
      // let parent know of changes to load status
      React.useEffect(function () {
          if (!prevIsLoaded && isLoaded) {
              onLoad();
          }
          if (prevIsLoaded && !isLoaded) {
              onUnload();
          }
      }, [isLoaded, onLoad, onUnload, prevIsLoaded]);
      // use parent element or fake one if it's not yet loaded
      var parentEl = parentRef.current || pseudoParentEl;
      // get parent element's dimensions
      var _q = parentEl.getBoundingClientRect(), height = _q.height, left = _q.left, top = _q.top, width = _q.width;
      var overlayStyle = getModalOverlayStyle({
          isLoaded: isLoaded,
          isUnloading: isUnloading,
          overlayBgColorEnd: overlayBgColorEnd,
          overlayBgColorStart: overlayBgColorStart,
          transitionDuration: transitionDuration,
          zoomZindex: zoomZindex,
      });
      var contentStyle = getModalContentStyle({
          height: height,
          isLoaded: isLoaded,
          innerHeight: innerHeight,
          innerWidth: innerWidth,
          isUnloading: isUnloading,
          left: left,
          originalTransform: parentEl.style.transform,
          top: top,
          transitionDuration: transitionDuration,
          width: width,
          zoomMargin: zoomMargin,
      });
      return isActive
          ? reactDom.createPortal(React__default["default"].createElement("div", { "aria-label": "Zoomed image", "aria-modal": true, "data-rmiz-overlay": true, role: "dialog", style: overlayStyle },
              React__default["default"].createElement("div", { "data-rmiz-modal-content": true, style: contentStyle }, children),
              React__default["default"].createElement("button", { "aria-label": closeText, "data-rmiz-btn-close": true, onClick: handleClick, ref: btnRef, type: "button" })), portalEl)
          : null;
  };
  var ControlledActivated$1 = React.memo(ControlledActivated);

  var Controlled = function (_a) {
      var children = _a.children, _b = _a.closeText, closeText = _b === void 0 ? 'Unzoom image' : _b, isActive = _a.isZoomed, _c = _a.overlayBgColorEnd, overlayBgColorEnd = _c === void 0 ? 'rgba(255, 255, 255, 0.95)' : _c, _d = _a.overlayBgColorStart, overlayBgColorStart = _d === void 0 ? 'rgba(255, 255, 255, 0)' : _d, portalEl = _a.portalEl, onZoomChange = _a.onZoomChange, _e = _a.openText, openText = _e === void 0 ? 'Zoom image' : _e, scrollableEl = _a.scrollableEl, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, _g = _a.wrapElement, WrapElement = _g === void 0 ? 'div' : _g, wrapStyle = _a.wrapStyle, _h = _a.zoomMargin, zoomMargin = _h === void 0 ? 0 : _h, _j = _a.zoomZindex, zoomZindex = _j === void 0 ? 2147483647 : _j;
      var _k = React.useState(false), isChildLoaded = _k[0], setIsChildLoaded = _k[1];
      var wrapRef = React.useRef(null);
      var btnRef = React.useRef(null);
      var handleClickTrigger = React.useCallback(function (e) {
          if (!isActive && onZoomChange) {
              e.preventDefault();
              onZoomChange(true);
          }
      }, [isActive, onZoomChange]);
      var handleChildLoad = React.useCallback(function () {
          setIsChildLoaded(true);
      }, []);
      var handleChildUnload = React.useCallback(function () {
          setIsChildLoaded(false);
          if (btnRef.current) {
              btnRef.current.focus({ preventScroll: true });
          }
      }, []);
      var wrapType = isChildLoaded ? 'hidden' : 'visible';
      return (React__default["default"].createElement(React.StrictMode, null,
          React__default["default"].createElement(WrapElement, { "data-rmiz-wrap": wrapType, ref: wrapRef, style: wrapStyle },
              children,
              React__default["default"].createElement("button", { "aria-label": openText, "data-rmiz-btn-open": true, onClick: handleClickTrigger, ref: btnRef, type: "button" }),
              typeof window !== 'undefined' && (React__default["default"].createElement(ControlledActivated$1, { closeText: closeText, isActive: isActive, onLoad: handleChildLoad, onUnload: handleChildUnload, onZoomChange: onZoomChange, overlayBgColorEnd: overlayBgColorEnd, overlayBgColorStart: overlayBgColorStart, parentRef: wrapRef, portalEl: portalEl, scrollableEl: scrollableEl, transitionDuration: transitionDuration, zoomMargin: zoomMargin, zoomZindex: zoomZindex }, children)))));
  };
  var Controlled$1 = React.memo(Controlled);

  exports.Controlled = Controlled$1;
  exports["default"] = Uncontrolled$1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
